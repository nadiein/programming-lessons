# A coloured triangle is created from a row of colours, each of which is red,
# green or blue. Successive rows, each containing one fewer colour than the last,
# are generated by considering the two touching colours in the previous row.
# If these colours are identical, the same colour is used in the new row.
# If they are different, the missing colour is used in the new row.
# This is continued until the final row, with only a single colour, is generated.

# For example, different possibilities are:

# Colour here:            G G        B G        R G        B R
# Becomes colour here:     G          R          B          G
# With a bigger example:

#    R R G B R G B B
#     R B R G B R B
#      G G B R G G
#       G R G B G
#        B B R R
#         B G R
#          R B
#           G

# You will be given the first row of the triangle as a string and its your job
# to return the final colour which would appear in the bottom row as a string.
# In the case of the example above, you would the given 'RRGBRGBB' you should return 'G'.

# The input string will only contain the uppercase letters 'B', 'G' or 'R'
# and there will be at least one letter so you do not have to test for invalid input.
# If you are only given one colour as the input, return that colour.

# Challenge
# The specificity of this kata resides in the very large size of the input strings that your
# function will have to crunch and digest.

# With such large numbers, the challenge here will clearly not be about optimizing
# code execution, but about reducing algorithmic complexity.

# Please note that the test cases are randomly generated, so the actual time
# it takes to complete the tests can vary from one attempt to the next.
# A good solution, though, should be able to beat the timeout 99% of the time.


class WrongType(Exception):
    pass

# Solution one
def triangle_one(row):
    while len(row) > 1:
        new_row = ''

        for i in range(len(row) - 1):
            if row[i] == row[i+1]:
                new_row += row[i]
            else:
                if 'R' not in (row[i], row[i+1]):
                    new_row += 'R'
                elif 'G' not in (row[i], row[i+1]):
                    new_row += 'G'
                else:
                    new_row += 'B'
        row = new_row

    return row

# Solution two
from collections import deque

def triangle_two(row):
    row = deque(row)

    while len(row) > 1:
        new_row = deque()

        for i in range(len(row) - 1):
            if row[i] == row[i+1]:
                new_row.append(row[i])
            else:
                if 'R' not in (row[i], row[i+1]):
                    new_row.append('R')
                elif 'G' not in (row[i], row[i+1]):
                    new_row.append('G')
                else:
                    new_row.append('B')
        row = new_row

    return row[0]


import cProfile
import time
from timeit import default_timer as timer


if __name__ == '__main__':
    cProfile.run('triangle_one("RBGRBGBRGBRBRGGRBBGRBGBRBBGRBGGBRBGBBGRBGBRGRBGRBB")')
    cProfile.run('triangle_two("RBGRBGBRGBRBRGGRBBGRBGBRBBGRBGGBRBGBBGRBGBRGRBGRBB")')

    start_time = time.time()
    triangle_one('RBGRBGBRGBRBRGGRBBGRBGBRBBGRBGGBRBGBBGRBGBRGRBGRBB')
    triangle_two('RBGRBGBRGBRBRGGRBBGRBGBRBBGRBGGBRBGBBGRBGBRGRBGRBB')
    end_time = time.time()

    print('', end_time - start_time)
